# 《JavaScript 设计模式与开发实践》要点整理

## 单例模式

  - 定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点
  - 举例：网页登录框
  - 重点：
    - 惰性单例，instance实例对象在调用Singleton.getInstance的时候才被创建，而不是在页面加载好的时候就创建。
    - 通用的惰性单例，把创建对象和管理单例的逻辑分开
    ```javascript
    //管理单例
    var getSingle = function(fn){
        var result;
        return function(){
            return result || (result = fn.apply(this, arguments));
        }
    }
    //创建单例
    var createLoginLayer = function(){
        var div = document.createElement('div');
        ...
        return div;
    }
    //使用单例
    var createSingleLoginLayer = getSingle(createLoginLayer);
    ...
    ```

## 策略模式

  - 定义：定义一系列的算法，把它们一个个封装起来，并且使它们可以互相替换。
  - 举例：
    - 年终奖发放，根据级别的基本工资按照不同的倍数发钱。
    - 表单校验，单个规则/多个规则等
    - 缓动动画，小球的移动等
  - 重点：
    - 多态的体现
    - 算法的使用方式不变，但是算法的实现是变化的
    - 一个基于策略模式的程序至少需要两部分组成，一部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。第二个部分是环境类Context，Context接受客户的请求，随后把请求委托给某一个策略类。
    
## 代理模式

  - 定义：为一个对象提供一个代用品或占位符，以便控制对它的访问。
  - 举例：
    - 小明追MM，借助一个共同的朋友给女神送花
    - 保护代理：代理B可以帮助A过滤掉一些请求。保护代理用于控制不同权限的对象对目标对象的访问，但在JavaScript并不容易实现保护代理，因为我们无法判断谁访问了某个对象。
    - 虚拟代理（最常用）：把一些开销很大的对象，延迟到真正需要它的时候才去创建
    - ==虚拟代理实现图片的预加载==
    - 虚拟代理合并http请求，减少频繁的网络请求。
    - 缓存代理：计算乘积，ajax异步请求数据
  - 重点：
    - 代理的意义：==符合单一职责原则==
    - 不需要去预先猜测是否需要使用代理模式，当真正发现不方便直接访问某个对象的时候，再编写代理也不迟

## 迭代器模式

  - 定义：提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。
  - 举例：
    - jQuery中的迭代器
    - 内部迭代器：函数内部定义好了迭代规则。在调用时非常方便，外界不关心迭代器内部的实现。
    - 外部迭代器：必须显示的请求下一个元素。增加了调用的复杂度，但是增强了迭代器的灵活性。
    - 倒序迭代器
    - 中止迭代器：提供跳出循环的方法。
    - ==根据不同的浏览器获取相应的上传组件对象==
  - 重点：
    - 迭代类数据对象和字面量对象，比如arguments。只要迭代的聚合对象拥有length属性而且可以用下标访问，那么它就可以被迭代。

## 发布-订阅模式（观察者模式）

- 定义：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。
- 举例
  - 售楼处和购房者：有任何消息，售楼处通知购房者，而不是购房者每天打电话询问有没有消息。
  - DOM事件，在DOM节点上绑定事件函数，就是发布-订阅模式
  - 让所有对象都拥有发布-订阅功能，把发布-订阅功能提取出来，放在一个单独的对象内；再定义一个函数，这个函数可以给所有的对象都动态安装发布-订阅功能。
  - 取消订阅
  - 网站登录，获取用户信息成功之后，设置header模块的头像、设置导航模块的头像、刷新消息列表、刷新购物车列表。==使用发布订阅模式，对用户信息感兴趣的业务模块将自行订阅登录成功的消息事件。==
  - 全局的发布-订阅对象，给每个发布者都添加listen和trigger方法以及一个缓存列表，是一种资源浪费。小明和售楼处对象还是存在一定的耦合性，小明至少需要知道售楼处对象的名字是salesOffices，才能顺利的订阅到事件。==发布-订阅模式可以用一个全局的Event对象来实现，订阅者不需要了解消息来自于哪个发布者，发布者也不知道消息会推送给哪些订阅者。==
  - 模块间通信，基于全局的发布-订阅模式，可以利用它在两个封装良好的模块中进行通信。==太多的全局发布-订阅模式，模块间的联系被隐藏到了背后，最终会搞不清楚消息来自哪个模块，会给委会带来一些麻烦。==
  - 先发布后订阅，建立一个存放离线事件的堆栈，事件发布时还没有订阅者来订阅，把发布时间包裹在包装函数里存入堆栈。有人来订阅，遍历堆栈并且依次执行包装函数，也就是重新发布里面的事件。
  - 使用命名空间
  - ==一个很大很全的发布-订阅模式代码==
- 重点：
  - 发布-订阅模式可以广泛应用于异步编程中，这是一种替代传递回调函数的方案。 
  - 发布-订阅模式可以取代对象之间的硬编码的通知机制，一个对象不用再显示地调用另外一个对象的某个接口。 
  - 推模型是指在事件发生时，发布者一次性把所有更改的状态和数据都推送给订阅者。
  - 拉模型，发布者仅仅通知订阅者事件已经发生了，发布者需要提供一些公开的接口供订阅者主动拉取数据。拉模型的好处是可以让订阅者“按需获取”，同时有可能让发布者变成一个“门户大开”的对象，增加了代码量和复杂度。、
  - 在JavaScript中，arguments可以很方便的表示参数列表，所以我们一般会选择==推模型==，使用Function.protype.apply方法把所有的参数都推送给订阅者。
  - 缺点：创建订阅者要消耗一定的时间和内存；当订阅一个消息后，也许消息最后都未发生，但这个订阅者会始终存在内存中。过度使用会减少对象之间的联系，导致程序难以跟踪维护和理解。
